# 容器到底是什么

# 隔离哪些资源

- 防冲突
  - 文件系统
  - 网络
  - 进程
  - 用户
- 约束
  - cpu, 内存， IO

# 从代码到容器需要几步

- Dockerfile
- 打镜像
- 启动容器

镜像和容器的关系

- 类与实例
- 分层式的文件系统

# Dockerfile最佳实践

一个好的Dockerfile是快速编译打包的关键

- 不常变化的指令放前面，npm install
- 减少指令行数
- 减少文件数 .dockerignore
- 尽量利用多核并行编译

# 容器网络

- host 与主机启动没有区别，需要作端口管理
- Bridge 独立网络栈，基于**iptables** 的NAT转换 端口转发
- Overlay (vxlan) 独立网络栈，且跨主机IP互通，共享ip池
- **坑， ip分配不一致，同一ip分配给不同容器**

# 容器调度

## 维度

- 主机标签化 (集群名，是否有公网IP)
- 健康状态
- 容量(内存，容器数)
- 网络 (IP, 端口)

## HA策略

- 资源足够的情况下，强制跨主机(机柜机房)部署
- 自恢复，故障迁移

# 容器监控

## 指标

cpu、内存、网络、磁盘IO

## 方案

- catvisor + prometheus + grafana（拉取、单点、可根据业务划分）
- cadvisor + ELK (上报，可横向扩展 )

# 镜像管理

- 容量
- 访问控制
- 存储优化

# 方案

- registry + nginx + 清理脚本
- registry + habor

# 服务注册发现

## 注册

- 应用自注册 对网络有要求或感知宿主机地址
- 外部注册 跨技术栈、简单粗暴

## 发现(负载均衡)

- 关注点： 容错，实时性
- 分类： 客户端，服务端

容器的利和弊

## 利

- 系统环境一致性（系统，依赖等）
- 技术栈自由度（语言版本、框架类型）
- 伸缩能力强（资源利用率、易迁移）

弊

- 单节点的稳定性
- **网络损耗**
- 资源隔离不彻底

容器技术栈

| 组件功能 | 组件名         |
| ---- | ----------- |
| 容器   | docker      |
| 窗口调试 | swarm       |
| 容器监控 | Cadvisor    |
| 服务注册 | Registrator |
| 服务发现 | Consul      |
|      |             |
|      |             |



# 机遇与挑战

- 技术演进的成本变低，传统运维配置管理越来越轻
- 大环境下容器的认识不够，自动化的过程中，不可能一步到位，完全隐藏掉容器细节，开发学习的成本