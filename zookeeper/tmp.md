[TOC]

# master-slave

通常这种架构master进程负责追踪workers和任务的可用性，还要指派任务给workers。对ZooKeeper严密说，这种架构风格很有代表性，因为它阐述了很多常见的任务，比如选举master,追踪可用的worker,维护应用数据。

## master崩溃

master发生错误变得不可用，系统不能分配新的任务或者重新分配那些来自worker已经失败的任务

为了应对, 我们需要有备用的master,当主master崩溃时，备用的master能够接管主master的工作。新的主master必须恢复当老的master崩溃时系统的状态。为了恢复master的状态，我们不能依赖拉取来自错误的master的状态，因为它已经崩溃了，我们必须从其它地方获取，这个地方就是zookeeper。

恢复状态不是唯一重要的问题。假设这样一个情景:  主master正常运行，但是备用master怀疑主master崩溃了，这种错误的怀疑是可能发生的，比如主master的负载非常高导致它的消息被延迟了。备份master会执行所有必要的步骤去接管主master的角色，最终可能会导致它开始执行主master的角色，变成第二个主master,更糟糕的是，如果某些worker由于网络分区的原因无法和主master进行通信，它们最终可能会追随第二个主master。这种情景导致了一个被称之为脑裂的问题，系统内两个或者多个独立的发展，导致了行为的不一致性。作为接下来应对master失败的部分方案，避免脑裂场景的发生是至关重要的。



## worker崩溃

如果woker崩溃，那些已经指定给它的任务就不会完成。



客户机提交任务给master, 由master分配任务给可用的workers. 这些workers接收被分配的任务，一旦这些任务被执行它们就会上报状态。master随后就会通知客户端执行的结果

如果一个worker崩溃，所有分配给它的未完成的任务必须被重新分配。第一个要求就是给master能够检测woker崩溃的能力，它可能最终部分的执行了任务，或者完全执行完了任务但是还没来得及上报结果。如果计算还有副作用的话，为了清理状态某些恢复步骤可能就很有必要了。

## Communitation失败

如果master和worker不能交换信息，那么worker可能就不能得到新的分配给它的任务。

为了处理这些问题，系统必须能可靠的选举出新的master，如果前面的那个发生错误，决定哪一个worker是可用的，以及决定何时一个worker相对于系统其它部分变得陈旧。



如果一个worker和master失去连接，比如网络分区的原因，重新分配任务可能导致两个worker执行同一个任务。如果一个任务被执行多次是可以接受的，我们在重新分配任务时就可以不用校验第一个任务是否执行过任务，如果不能接受，那么应用必须能够适应多个worker最终都可能执行该任务的可能。



### 有且仅有一次(exactly-once) 和 最多一次(at-most-once)

对任务（比如领导者选举）使用锁并不能完全避免任务被执行多次，因为可能会存在以下几个连续的事件:

1. Master M1指定任务T1给Worker1 W1
2. W1获取T1的锁，然后执行T1, 接着释放锁
3. Master M1怀疑W1崩溃了，然后重新分配任务T1给Woker W2
4. W2获取了T1的锁，执行T1, 接着释放锁

这种情况下，T1的锁没有阻止任务被执行两次，因为两个worker之间在执行任务时没有重叠的步骤。为了处理那些需要仅有一次或者最多一次语义的场景，应用需要依赖特定的机制。比如说，应用数据包含时间戳，而一个任务需要修改这个应用数据，那么任务的成功执行取决于那个数据创建的时间戳的值。该应用在状态不是自动修改的情况下需要有能力回滚部分变更的能力；否则，它可能最终导致一个不一致的状态。

我们通过这些讨论来阐述了为应用实现这些语义的难点。讨论这些语言的具体实现不在本书的范围内。



另外一个通信失败的重要问题是它们对同步原语(比如锁)产生的影响。因为节点可能崩溃，系统可能会有网络分区，锁会产生问题: 如果一个节点崩溃或者被分区，锁可以阻止其它的节点继续运行。Zookeeper随后需要实现处理这种场景的机制。首先，它使得客户端指定在Zookeeper中的某些数据状态是临时的。其次，Zookeeper集群需要客户端周期性通知它们是存活的。如果一个客户端没有及时地通知集群，那么所有属于这个客户端的临时状态都会被删除。通过这两个机制，在崩溃和通信失败的情况下，我们能防止单独的客户端导致应用停止执行。



回想前面我们讨论过，在系统中我们无法控制消息的延迟，所以无法分辨一个客户端是否崩溃还是只是运行很慢。因此，当我们怀疑一个客户端已经崩溃时，我们需要假设它仅仅是运行得很慢，这样在未来它还有可能执行某些其它的动作。



## 任务总结

在前面的描述中，我们可以对master-worker架构提取出下面几个要求:

### 领导者选举

有一个可用的master并且能分配任务给worker是至关重要的。

### 崩溃检测

