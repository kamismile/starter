[TOC]

# master-slave

通常这种架构master进程负责追踪workers和任务的可用性，还要指派任务给workers。对ZooKeeper严密说，这种架构风格很有代表性，因为它阐述了很多常见的任务，比如选举master,追踪可用的worker,维护应用数据。

## master崩溃

master发生错误变得不可用，系统不能分配新的任务或者重新分配那些来自worker已经失败的任务

为了应对, 我们需要有备用的master,当主master崩溃时，备用的master能够接管主master的工作。新的主master必须恢复当老的master崩溃时系统的状态。为了恢复master的状态，我们不能依赖拉取来自错误的master的状态，因为它已经崩溃了，我们必须从其它地方获取，这个地方就是zookeeper。

恢复状态不是唯一重要的问题。假设这样一个情景:  主master正常运行，但是备用master怀疑主master崩溃了，这种错误的怀疑是可能发生的，比如主master的负载非常高导致它的消息被延迟了。备份master会执行所有必要的步骤去接管主master的角色，最终可能会导致它开始执行主master的角色，变成第二个主master,更糟糕的是，如果某些worker由于网络分区的原因无法和主master进行通信，它们最终可能会追随第二个主master。这种情景导致了一个被称之为脑裂的问题，系统内两个或者多个独立的发展，导致了行为的不一致性。作为接下来应对master失败的部分方案，避免脑裂场景的发生是至关重要的。



## worker崩溃

如果woker崩溃，那些已经指定给它的任务就不会完成。



客户机提交任务给master, 由master分配任务给可用的workers. 这些workers接收被分配的任务，一旦这些任务被执行它们就会上报状态。master随后就会通知客户端执行的结果

如果一个worker崩溃，所有分配给它的未完成的任务必须被重新分配。第一个要求就是给master能够检测woker崩溃的能力，它可能最终部分的执行了任务，或者完全执行完了任务但是还没来得及上报结果。如果计算还有副作用的话，为了清理状态某些恢复步骤可能就很有必要了。

## Communitation失败

如果master和worker不能交换信息，那么worker可能就不能得到新的分配给它的任务。

为了处理这些问题，系统必须能可靠的选举出新的master，如果前面的那个发生错误，决定哪一个worker是可用的，以及决定何时一个worker相对于系统其它部分变得陈旧。



如果一个worker和master失去连接，比如网络分区的原因，重新分配任务可能导致两个worker执行同一个任务。如果一个任务被执行多次是可以接受的，我们在重新分配任务时就可以不用校验第一个任务是否执行过任务，如果不能接受，那么应用必须能够适应多个worker最终都可能执行该任务的可能。



### 有且仅有一次(exactly-once) 和 最多一次(at-most-once)

对任务（比如领导者选举）使用锁并不能完全避免任务被执行多次，因为可能会存在以下几个连续的事件:

1. Master M1指定任务T1给Worker1 W1
2. W1获取T1的锁，然后执行T1, 接着释放锁
3. Master M1怀疑W1崩溃了，然后重新分配任务T1给Woker W2
4. W2获取了T1的锁，执行T1, 接着释放锁