# JarsLink源码探究

[TOC]

# 隔离性

## 类隔离

### classloader

### 实战加载同一种框架不同版本

## 实例隔离

### 如何实现为每个模块创建独立的spring上下文，并保证失败后不影响其它模块

## 资源隔离， 使用独立的cpu和内存资源

## 动态性

### 模块在运行时动态加载到系统中，不需要重启和发布系统新增功能。

### 双亲委派机制

### 如何突破双亲委派机制，在运行时加载父加载器已经加载过的类，实现模块升级依赖包不需要系统发布

### 动态卸载: 模块在运行时动态卸载，实现快速下线不需要的功能



## 易用性: 有设计哪些通用灵活的api让系统和模块进行交互

## 实现原理

### 模块加载

> 为每个模块创建一个新的URLClassLoader来加载模块，并且为每个模块创建一个独立的IOC容器来存放本模块的BEAN. 支持突破双新委派，申明了overridePackages的包将由子类加载进行加载。

### 模块的卸载

> 模块的卸载需要满足三个条件
>
> 1. 模块里的实例对象没有被引用
> 2. 模块里的class没有被引用
> 3. 类加载器没有被引用
>
> 所以需要做到三点卸载实例，卸载类和卸载类加载器，整个模块的卸载顺序如下
>
> ```mermaid
> graph LR;
> 1(关闭资源)
> 2(关闭IOC容器)
> 3(去掉引用类加载器)
> 4(卸载JVM租户)
> 1 --> 2
> 2 --> 3
> 3 --> 4
> ```
> 4.  关闭资源: 关闭http连接池或线程池
> 5. 关闭ioc容器: 调用applicationContext.close()方法关闭IOC容器
> 6. 移除类加载器: 去掉模块的引用
> 7. 卸载JVM租户(开发中): 卸载该模块使用的JVM租户，释放资源

### 模块间隔离

> 模块化开发需要解决隔离性问题，否则各模块之间会互相影响。
>
> 模块之间的隔离有三个层次，类隔离，实例隔离和资源(cpu和内存)隔离。目前实现了类隔离和实例隔离,通过
>
> 为每个模块创建一个类加载器来实现类隔离，通过为模块创建一个新的IOC容器来实现实例隔离。资源隔离
>
> 准备引入JVM多租户来解决。

### 模块间通讯

> 模块间通讯有三种方式， RPC, 本地调用，深克隆/反射
>
> 1. 本地调用： 目前JarLink的doAction就是使用这种通讯方式，这种方式要求模块的类加载器是父子关系，且IOC容器也是父子容器
> 2. RPC调用: 用于跨JVM的模块之间调用，利用SOFA 4动态api在模块中发布和引用TR服务来实现
> 3. 深克隆/反射 (集成中): 深克隆其它模块的入参，反射其它模块的方法实现调用。



### 类加载机制

> OSGI 类加载机制的关系采用的是网状结构，每个模块通过export-package来声明我要给别人用哪些类，通过import-package来声明
>
> 我要用别人的哪些类。而jarslink采用的是扁平化管理，每个模块都有一个共同的父类，这个父类加载器就是加载moduleLoader类的加载器

### JarsLink框架类图

> 1. ModuleLoader: 模块加载引擎，负责模块加载
> 2. ModuleManager: 模块管理者，负责在运行时注册，卸载，查找模块和执行action
> 3. module: 模块，一个模块有多个action
> 4. Action: 模块里的执行者

## 应用场景







